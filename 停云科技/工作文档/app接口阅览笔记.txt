app接口阅览笔记

杂记：
1.account操作以及order操作的请求会进行token的校验拦截。通过传过来的appkey从缓存服务器中获取token值，将其和传过来的token进行比较，如果一致的话，允许下一步操作。


一 登陆和登出接口
登陆。只允许进行post数据提交，通过用户名从数据库中获取appuser对象，并进行账户的完备性检查（账户是否可用，是不是被锁了等），之后则需要对用户的密码进行匹配，转过码的。appuser和用户积分表以及会员等级表有关联。级联查询出这些数据，并一起封装用于登陆成功后的数据存储用。然后根据本次的登陆请求，创建出唯一的token值，并保存到缓存中。
同时在进行登陆操作的时候，需要对当前购物车的信息做一下保存或者获取的处理，下面详解。
系统分别有对应的用户级别的（存储在数据库）以及session级别的（数据也存储在数据库）购物车信息。这里分别根据userid和sessionid进行查询。查询的顺序如下：看是否传过来的信息中包含userid，有的话，会先根据userid进行查询，查询到的话，直接返回结果。如果没查询到的话，就对sessionid来进行查询（情景为未登陆的用户会根据浏览器中存储的sessionid来进行保存用户购物车中的相关信息，一旦这时候查询到了该未登陆用户登陆了系统，则会更新userid字段。总之一点就是：未登陆根据cookie标志从数据库取数据，登陆了的根据userid从数据库中取数据，如果两个都没有获取到，则直接返回空）。
将这两个都取出来之后，先后判断顺序也是先用户后session。如果根据用户的没查询到，根据session的查询到了，说明是新用户，之前没保存过的相关信息，直接创建购物车对象，取出session中商品信息，清除旧购物车信息，并将购物车信息和里面商品信息保存。
如果根据用户的查询到了，sessionid中的也查询到了，这时候就需要对两块儿信息进行合并并剔除重复的部分，并存储返回数据。
在保存完购物车的相关信息之后，将刚才创建的token，以及对应的json体返回到前端。（其实这里个人觉得，保存购物车的操作可以交给线程池来做，参数构造好后直接返回就好了，保存数据库的操作，留给线程慢慢处理。可以加快不少的响应时间）

登出。比较简单，直接remove掉缓存中appkey对应的token，这样再此请求关于account或者order的请求之后，就会被拦截器拦截。（seesionn状态貌似没有被主动注销？个人觉得有必要主动进行session清除，不然session请求过多影响性能。ps，其实代码已经做了登出操作了，获取的HttpServletRequest,通过request获取到当前会话的session对象，并调用invalidate方法即可清除当前session对象的数据)

二 首页数据获取
只有一个接口，接口的数据获取的是首页所有的模块数据。目前首页数据是依据线性的方式逐步获取，因为每个接口都会占用大量的调用时间，因此这里也需要放入线程池，多线程并行处理请求。当所有数据都处理完毕之后，再返回结果。
首页广告banner。有三种模式，分别为链接单个的商品详情，链接对应的商品目录，以及链接对应的宣传页面。广告位类型存在表AD_POSITION_TYPE中，广告数据存储在表advertisement中。搜索的时候首先根据广告类型（mobileMid），获取到对应的广告位类，之后根据广告位id和类型以及分类，查出所对应的广告信息列表，（product_advertisement表为商品目录与广告关系映射表，之间是一对多的关系，可能存在多个目录对应同一个广告）。
热卖商品和新上架商品。都是使用getProductsByRecommendedTypeNameBySourceIdList(ProductService)方法，通过传递不同的推荐参数获取推荐商品数据。根据推荐名称（new-arrival，top-recommend等）获取表recommended_type的对象后，将对应的推荐id，搜索类型（商品），以及需要查询的范围，在表recommended_product中捞取到对应的productid列表。【mgr后台的对应推荐类型数据在marketing中进行配置，在哪儿配置推荐商品目前暂不知】
CLICK AND SHIP商品。通过getProductListInBlackFriday(ProductActivityService)方法获取相关数据，也就是说这获取black_friday表类型的商品。不考虑目录结构，不考虑商品名称，只根据活动价格的高低获取目前表里的所有商品数据类型。获取到商品列表数据之后根据每件商品的默认skuId找到对应的sku商品，并添加到对应的ProductVo对象中返回。

三 商品信息目录结构获取等接口
