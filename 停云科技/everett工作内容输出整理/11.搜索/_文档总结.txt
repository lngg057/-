搜索项目主要分两部分：
一部分是solr引擎主体，提供储存，索引，搜索相关数据的功能。
另一部分是solr-java项目，用来组织并调用solr搜索服务，提供对外接口。

以上的两部分具体怎么搭建，以及相关的整合部分，可以参考之前留下的文档，文档为
goods搜索服务器 linux环境搭建文档.doc
goodssearch-service搜索接入.doc

搜索的实际调用过程为：
solr引擎 -- solrj接口调用 -- goodssearch-service服务 -- 对外项目接口调用

之前的项目就不多强调，这边主要讲一下搜索服务中新增加的部分。

1.goodssearch-service服务中，在原有的服务基础上，添加了以下的搜索服务：Group搜索结果分组功能，Stats聚合查询功能。
这些功能作为补充，添加到了public JSONArray searchForBondAndPrice(SearchConditions searchConditions);这个方法中。
这两个功能相对独立，且和之前的搜索结果功能独立。开启某方法的方式，是在 SearchConditions 对象中，将对应的功能字段置成true，这样，搜索返回的结果便是，该对应功能处理完后的结果了。

2.服务中添加了edismax，搜索权重排序。这个过滤条件与目前其他的排序共存，根据SearchConditions中的sorts关键字判断，如果sort的key包含"relevance"字段，则开启权重排序功能，否则直接按照以前的排序功能。
目前权重设计的代码如下：sub(sum(product(div(buyCount,1000),400),product(div(viewCount,18000),300),product(recip(ms(NOW,shelveTime),1,100,100),100)),product(div(minPrice,1200000),200))。
这个公式按照 商品购买数量（4/10）、商品查看次数（3/10）、商品上架时间（2/10），以及商品的售价（1/10）进行商品的比重权衡排序，最终查询出来的结果就是所谓的“综合排序”。具体的代码详见goodssearch-service服务中的对应代码

3.服务中重新使用了facet分片搜索功能，主要用来从现有的索引结果中，匹配搜索关键词对应的类似词组，按照匹配度进行配需。


额外说一句，因为之前项目编写的扩展性不高，json格式封装的很死，基本没有插入其他节点的可能性，如果想修改之前的json格式，就必须得修改现在的所有项目代码，可操作性很低。

实际上，solr搜索的结果的格式是固定如下的：
"response": {}  ---  这个是基本的查询出来的结果，当为默认的查询结果时候，都会存在该结构体，里面是查询出来的所有匹配结果集。
"grouped": {}  ---  这个是开启搜索分组功能（针对某个索引字段进行分组）之后，会存在的结构体。里面的元素会按照查询关键字所在的分组数量进行先后排序。所以这个功能目前被用来查询关键字商品高匹配的目录。
"stats":{}  ---  这个会伴随着response结构体而出现，在开启了stats聚合查询之后会出现该结构体。solr的聚合查询针对索引字段，包含了一些最基本的计算功能，包括：搜索结果中，索引字段的最大值、索引字段的最小值；查询出来的所有结果总数；匹配失败的结果数；索引字段所有结果的值总和；索引字段所有值总和的平方，等。本项目目前只用到了索引字段对应查询结果的最大值，以及最小值的功能，用于统计搜索结果中，价格的最大值以及最小值。
...

基本solr返回的json结构体都是以以上描述的格式所存在。所以，在封装JSON对象的时候，其实也可以按照上面描述的形式，进行分组封装。这样，作为调用接口的使用方，也会比较方便进行业务扩展，在新增其他功能的时候，也不会影响现有业务。
但是之前的搜索结果只返回了商品搜索结果，其他的一概没有位置插入，所以这里新增功能的时候，没办法只能重写代码，根据实际情况，返回对应的JSON结构体
